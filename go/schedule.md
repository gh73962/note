# Schedule
## Basic
process : 操作系统的基本执行单元,也是基本分配单元 ; 进程是一个实体, 每个进程都有自己的地址空间      
thread : 包含在进程中,是进程的实际执行单位,共享进程的环境和资源     

## 调度
G : goroutine 使用了更少的内存空间, 减少了上下文切换的开销      
M : 工作线程或machine, 数量基于CPU核心数    
P : 处理器(非硬件意义),执行GO代码所需的资源. M 必须被分配到P上来执行GO代码, 可被阻塞或系统调用      

### 调度器版本
1.  单线程调度器
    1. 获取调度器的全局锁
    2. 保存栈寄存器和PC
    3. 获取下去需要运行的gr并解锁调度器
    4. 修改m上要运行的gr
    5. 运行最新的gr
2.  多线程调度器 
    1.  问题:
        1.  调度器和锁都是全局资源,所有的调度状态都是中心化存储,锁竞争问题严重
        2.  线程经常需要相互传送可运行的gr,引入了大量延迟
        3.  每个线程都需要处理内存缓存,导致大量内存占用并影响数据局部性
        4.  系统频繁调用阻塞和接触阻塞正在运行的线程
3.  任务窃取调度器
    1.  引入P作为中间层,在P上实现工作窃取
    2.  调度流程
        1.  处理gc等待状态
        2.  从本地或全局运行队列中获取待执行的gr
        3.  在当前m上执行gr
            1.  要是当前本地队列没有gr时,会触发窃取从其他m上随机获取一些gr
4.  抢占式调度器
    1.  go在分段栈的机制上实现抢占调度,利用编译器在分段栈上插入的函数,所有gr在函数调用时都有机会进入runtime检查是否需要执行抢占,g的stackguard0=StackPreempt
    2.  基于协作的抢占式调度器
        1.  问题1 for{}永远无法触发抢占点, 故gc无法完成, 进而饿死其他G .(问题可广义化)
        2.  通过编译器在函数调用时插入抢占检查指令，在函数调用时检查当前 Goroutine 是否发起了抢占请求，实现基于协作的抢占式调度；
        3.  工作原理
            1.  编译器在调用函数前插入runtime.morestack
            2.  runtime会在gc stw和系统监控发现gr运行超过10ms时,发出抢占请求StackPreempt
            3.  当发生函数调用时,可能会执行插入的runtime.morestack,newstack会检查gr的stackguard0, == StackPreempt 就让出当前的m
    3.  基于信号的抢占式调度器(为了解决 垃圾回收和栈扫描时存在的问题,STW 和栈扫描是一个可以抢占的安全点)
        1.  实现基于信号的真抢占式调度
        2.  抢占的时间点不够多，还不能覆盖全部的边缘情况
        3.  工作流程    
            1.  注册信号函数sigurg
            2.  触发垃圾回收的栈扫描时会调用函数挂起gr
                1.  将runing的gr标记为可抢占,然后触发抢占
            3. 向m发送信号SIGURG到m
            4. os中断当前正在运行的m,并执行预先注册好的函数获取当前的SP和PC并调用函数修改寄存器并在程序回到用户态时调用函数修改当前 Goroutine 的状态到 _Gpreempted 并调用函数让当前函数陷入休眠并让出线程,调度器会选择其它的 Goroutine 继续执行
### 信号抢占过程
1.  注册信号SIGURG和信号函数
2.  改变标志位触发抢占
3.  向线程发送信号SIGURG
4.  OS中断当前在运行的线程,并执行预先注册号的信号函数runtime.doSigPreempt

### 任务队列
全局队列: 归属于调度器      
本地队列: 归属于当前的P (数组构成的环形链表,最多256)        
#### 队列运行
本地队列未满则塞入本地队列内        
本地队列已满则放入全局队列      
runtime.findrunnable (一定会返回一个可执行的 Goroutine，如果当前不存在就会阻塞等待)       
1.  从本地运行队列、全局运行队列中查找
2.  从网络轮询器中查找是否有 Goroutine 等待运行
3.  通过 runtime.runqsteal 尝试从其他随机的处理器中窃取待运行的 Goroutine，该函数还可能窃取处理器的计时器

### 触发调度的情况
1.  主动挂起 gopark -> park_m
2.  系统调用
3.  协作式调度 runtime.Gosched -> runtime.gosched_m -> runtime.goschedImpl
4.  系统监控