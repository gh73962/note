# Schedule
## Basic
process : 操作系统的基本执行单元,也是基本分配单元 ; 进程是一个实体, 每个进程都有自己的地址空间      
thread : 包含在进程中,是进程的实际执行单位,共享进程的环境和资源     

## 调度
G : goroutine 使用了更少的内存空间, 减少了上下文切换的开销      
M : 工作线程或machine, 数量基于CPU核心数    
P : 处理器(非硬件意义),执行GO代码所需的资源. M 必须被分配到P上来执行GO代码, 可被阻塞或系统调用      

### 调度器版本
1.  单线程调度器 (确定G M) (需要主动让出资源)
2.  多线程调度器 (主要问题是调度时的锁竞争会严重浪费资源) (需要主动让出资源)
3.  任务窃取调度器 (引入P作为中间层,在P上实现工作窃取) (需要主动让出资源)
4.  协作 抢占式调度器 (为了解决 1.某些goroutine可以长时间占用线程,饿死其他G; 2.长时间STW会导致程序不可用;)
    1.  问题1 for{}永远无法触发抢占点, 故gc无法完成, 进而饿死其他G .(问题可广义化)
5.  信号 抢占式调度器 (为了解决 垃圾回收和栈扫描时存在的问题,STW 和栈扫描是一个可以抢占的安全点)
### 信号抢占过程
1.  注册信号SIGURG和信号函数
2.  改变标志位触发抢占
3.  向线程发送信号SIGURG
4.  OS中断当前在运行的线程,并执行预先注册号的信号函数runtime.doSigPreempt

### 任务队列
全局队列: 归属于调度器      
本地队列: 归属于当前的P (数组构成的环形链表,最多256)        
#### 队列运行
本地队列未满则塞入本地队列内        
本地队列已满则放入全局队列      
runtime.findrunnable (一定会返回一个可执行的 Goroutine，如果当前不存在就会阻塞等待)       
1.  从本地运行队列、全局运行队列中查找
2.  从网络轮询器中查找是否有 Goroutine 等待运行
3.  通过 runtime.runqsteal 尝试从其他随机的处理器中窃取待运行的 Goroutine，该函数还可能窃取处理器的计时器

### 触发调度的情况
1.  主动挂起 gopark -> park_m
2.  系统调用
3.  协作式调度 runtime.Gosched -> runtime.gosched_m -> runtime.goschedImpl
4.  系统监控